## 객체 지향 프로그래밍

### 절차 지향 프로그래밍

- 시간이나 사건의 흐름에 따른 프로그래밍 

### 객체 지향 프로그래밍
- 객체 정의
- 객체 제공하는 기능들을 구현
- 각 객체가 제공하는 기능들 간의 소통(메시지 전달)을 통하여 객체간의 협력을 구현

> 클래스는 대문자로 시작
> 
> pulibc 클래스는 하나이고, public 클래스와 java 파일의 이름은 동일
> camel notation 방식으로 명명

## 함수와 메서드

### 함수란?

- 하나의 기능을 수행하는 일련의 코드
- 구현된 함수는 호출하여 사용하고 호출된 함수는 기능이 끝나면 제어가 반환됨

### 함수 호출과 스택 메모리
- 스택 : 함수가 호출될 때 지경 변수들이 사용하는 메모리
- 함수의 수행이 끝나면 자동으로 반환 되는 메모리                

main 에서 add 함수 호출 시 -> add() 함수 공간이 스택에 생성됨 -> add() 함수가 사용한 메모리 공간은 자동으로 사라짐


## 05. 인스턴스 생성과 힙 메모리 (heap memory)
### *인스턴스*
- 클래스는 객체의 속성(인스턴스 변수)을 정의 하고, 기능을 구현하여 만들어 놓은 코드 상태
- 실제 클래스 기반으로 생성된 객체(인스턴스)는 각각 다른 멤버 변수 값을 가지게 됨
- new 키워드를 사용하여 인스턴스 생성 (인스턴스는 힙 메모리에 올라온 상태)
### 힙 메모리
- 생성된 인스턴스는 동적 메모리 (heap memory)이 할당됨
- C 나 C++ 언어에서는 사용한 동적 메모리를 프로그래머가 해제 시켜야 함
- 자바에서 Garbage Collector 가 주기적으로 사용하지 않은 메모리를 수거
- 하나의 클래스로부터 여러개의 인스턴스가 생성되고 각각 다른 메모리 주소를 가지게됨
> 스택 메모리 -> 함수에서 사용 -> 함수의 지역변수들이 사용하는 메모리 
> 
> 힙 메모리 -> 동적으로 할당 (생성된 인스턴스)

- 객체 : 객체 지향 프로그램의 대상, 생성된 인스턴스
- 클래스 : 객체를 프로그래밍 하기위해 코드를 정의
- 인스턴스 : new 키워드를 사용하여 클래스를 메모리에 생성한 상태
- 멤버 변수 : 클래스의 속성, 특성
- 메서드 : 멤버 변수를 이용하여 클래스의 기능을 구현
- 참조 변수: 메모리에 생성된 인스턴스를 가리키는 변수
- 참조 값: 생성된 인스턴스의 메모리 주소 값

## 06. 생성자에 대해서

### 생성자
- 객체를 생성할 때 new 키워드와 함께 사용 - new Student();
- 생성자는 일반 함수처럼 기능을 호출하는 것이 아니고 객체를 생성하기 위해 new 와 함께 호출
- 객체가 생성될 때 변수나 상수를 초기화 하거나 다른 초기화 기능을 수행하는 메서드를 호출 함
- 생성자는 반환 값이 없고, 클래스의 이름과 동일
- 대부분의 생성자는 외부에서 접근 가능하지만, 필요에 의해 private 으로 선언된는 경우도 있음

## 07. 생성자 오버로딩
### 생성자 정의 하기
- 생성자를 구현해서 사용할 수 있음
- 클래스에 생성자를 따로 구현하면 기본 생성자는 제공 X
- 생성자를 호출하는 코드에서 여러 생성자 중 필요에 따라 호출해서 사용할 수 있음

## 08. 참조 자료형 변수
### 참조 자료형
- 기본 자료형 : int, long, float, double 등
- 참조 자료형 : String, Date, Student 등
- 클래스형으로 변수를 선언
- 참조 자료형을 사용 할 때는 해당 변수에 대해 생성해야함

## 09. 접근 제어 지시자 (access modifier) 와 정보은닉 (information hiding)
### 접근 제어 지시자
- 클래스 외부에서 클래스의 멤버 변수, 메서드, 생성자를 사용할 수 있는지 여부를 지정하는 키워드
- private : 같은 클래스 내부에서만 접근 가능 ( 외부 클래스, 상속 관계의 클래스에서도 접근 불가)
- 아무것도 없음 (default) : 같은 패키지 내부에서만 접근 가능 ( 상속 관계라도 패키지가 다르면 접근 불가)
- protected : 같은 패키지나 상속관계의 클래스에서 접근 가능하고 그 외 외부에서는 접근 할 수 없음
- public : 클래스의 외부 어디서나 접근 할 수 있음 

### get()/ set() 메서드
- private 으로 선언된 멤버 변수 (필드)에 대해 접근, 


## 10. 캡슐화

### 정보 은닉을 활용한 캡슐화

- 꼭ㄱ 필요한 정보와 기능만 외부에 오픈함
- 정보를 클래스화 해서 멤버 변수와 메서드를 감추고(private) 외부에 통합된 인터페이스만은 제공하여 일관된 기능을 구현 하게 함
- 각각의 메서드나 멤버 변수를 접근함으로써 발생하는 오류를 최소화 한다 

## 11. 객체 자신을 가리키는 this
### this가 하는 일
- 인스턴스 자신의 메모리를 가리킴
- 생성자에게 또 다른 생성자를 호출 할때 사용
- 자신의 주소(참조값)을 반환 함
### 생성된 인스턴스 메모리의 주소를 가짐
- 클래스 내에서 참조변수가 가지는 주소 값과 동일 한 주소 값을 가지는 키워드
### 생성자에서 다른 생성자를 호출하는 this
- 생성자에서 다른 생성자를 호출하는 경우, 인스턴스의 생성이 완전하지 않은 상태이므로 this() statement 이전에 다른 statement 를 쓸 수 없음
- 클래스에 생성자가 여러 개 인경우, this 를 이용하여 생성자에서 다른 생성자를 호출할 수 있음

## 12. 객체 간의 협력 (collaboration) 
### 객체 지향 프로그래밍에서의 협력
- 객체 지향 프로그램에서 객체 간에는 협력이 이루어짐
- 협력을 위해서는 필요한 메세지를 전송하고 이를 처리하는 기능이 구현되어야 함
- 매개 변수로 객체가 전달되는 경우가 발생
- 객체 협력의 예

## 13. 버스 타고 학교 가는 학생의 과정을 객체 지향 프로그래밍으로 구현

> James 와 Tomas 는 각각 버스와 지하철을 타고 학교에 간다
> 
> James 는 5000 원 가지고 있고, 100 번 버스 타면서 1000원 지불
> 
> Tomas 는 10000원 가지고 있고, 초록색 지하철을 타면서 1200원 지불

## 14. 여러 인스턴스에서 고통으로 사용하는 변수를 선언하자 - static 변수
### 공통으로 사용하는 변수가 필요한 경우
- 여러 인스턴스가 공유하는 기준 값이 필요한 경우
- 학생마다 새로운 학번 생성
- 카드회사에서 카드를 새로 발급할때마다 새로운 카드 번호를 부여
- 회사에 사원이 입사할때 마다 새로운 사번이 필요
### static 변수 선언과 사용하기
- 프로그램이 메모리에 로딩될 때 메모리 할당
- 인스턴스 생성과 상관없이 사용 가능하므로 클래스 이름으로 직접 참조
- 클래스 변수, 정적변수라고도 함
- 인스턴스 변수는, static 안에서 생성 못한다

## 15. static 응용 - 싱글톤 패턴
### 싱글톤 패턴이란?
- 프로그램에서 인스턴스가 단 한 개만 생성되어야 하는 경우 사용하는 디자인 패턴
- static 변수, 메서드를 활용하여 구현 할 수 있음
### 싱글톤 패턴으로 회사 객체 구현하기
- 생성자는 private 으로 선언
- 클래스 내부에 유일한 private 인스턴스 생성
- 외부에서 유일한 인스턴스를 참조할 수 있는 public 메서드 제공
- Calender은 유일한거라 singleton을 사용해야함


```
Calender calender = Calender.getInstance();
```

## 17. 자료를 순차적으로 한꺼번에 관리하는 방법 - 배열 (Array)

### 배열이란?
- 동일한 자료형의 순차적 자료 구조
- 인덱스 연산자[]를 이용하여 빠른 참조가 가능
- 물리적 위치와 논리적 위치가 동일
- 배열의 순서는 0부터 시작
- 자바에서는 객체 배열을 구현한 ArrayList를 많이 활용함
### 배열 선언과 초기화
- 배열 선언하기
```
int[] arr1 = new int[10];
// 총 40 바이트 배열을 allocation
```
배열은 선언과 동시에 자료형에 따라 초기화 됨 (정수는 0, 실수는 0.0, 객체는 Null)
필요에 따라 초기값을 지정할 수 있음
```
int[] numbers = new int[]{10, 20, 30}; //개수 생략해야함
int[] numbers = {10,20,30} // new int[] 생략 가능
int[] ids;
ids = new int[] {10,20,30}; // 선언 후 배열을 생성하는 경우는 New int[] 생략 불가
```
### 배열 사용하기
- [] 인덱스 연산자 활용 - 배열 요소가 저장된 메모리의 위치를 연산하여 찾아 줌

```
int[] arr1 = new int[10];
int arr2[] = new int[10];

int[] numbers = {1, 2, 3, 4};

for (int i = 0; i < numbers.length; i++) {
    System.out.println(i + "번째: " + numbers[i]);
}
```

### 배열의 길이와 요소의 개수는 동일하지 않습니다
- 배열을 선언하면 개수만큼 메모리가 할당되지만, 실제 요소(데이터)가 없는 경우도 있음
- 배열의 length 속성은 배열의 개수를 반환해주기 때문에 요소의 개수와는 다름

## 18. 객체 배열 사용하기 
### 객체 배열 선언과 구현
- 기본 자료형 배열은 선언과 동시에 배열의 크기만큼의 메모리가 할당되지만,
  객체 배열의 경우엔 요소가 되는 객체의 주소가 들어갈(4바이트, 8바이트) 메모리만 할당되고(null) 각 요소 객체는 생성하여 저장해야 함

## 20. 객체 배열을 구현한 클래스 ArrayList
### Java.util 패키지에서 제공되는 ArrayList
- 기존의 배열 선언과 사용 방식은 배열의 길이를 정하고 요소의 개수가 배열의 길이보다 커지면 배열을 재할당하고 복사해야 했는데
- 배열의 요소를 추가하거나 삭제하면 다른 요소들의 이동에 대한 구현 해야함
- ArrayList는 객체 배열을 좀더 효율적으로 관리하기 위해 자바에서 제공해주는 클래스

주요 메서드
- add()
- size()
- get()
- remove()
- isEmpty()

